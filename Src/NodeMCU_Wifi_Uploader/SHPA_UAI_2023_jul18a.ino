#include "arduino_secrets.h"
/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/bbed5ea9-d3e4-4efb-b8a5-7f91c1205049

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String calidadAire;
  CloudTemperatureSensor temperatura;
  CloudRelativeHumidity humedad;
  bool calidadAireBool;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
typedef struct Lecturas
{
  byte temp = 0;
  byte hum = 0;
  byte gas[4] = {0};
};

#include "thingProperties.h"
// WireData - Version: Latest
#include <Wire.h>
// LiquidCrystal I2C - Version: Latest
#include <LiquidCrystal_I2C.h>


#define LCD_I2C_ADDRESS 0x27                      //Direccion del modulo i2c del LCD         
#define LCD_DISP_COLS   16                        //Tamaño del LCD (Columnas)
#define LCD_DISP_ROWS   2                         //Tamaño del LCD (Filas)

LiquidCrystal_I2C lcd( LCD_I2C_ADDRESS, LCD_DISP_COLS, LCD_DISP_ROWS ); //Configuramos el LCD

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  lcd.init();                                   //Iniciamos el lcd.
  lcd.backlight();
  lcd.setCursor (0, 0);
  lcd.print("                ");
  lcd.setCursor (0, 1);
  lcd.print("                ");
  lcd.setCursor (0, 0);
  lcd.print("   Monitor de  ");
  lcd.setCursor (0, 1);
  lcd.print("   temperatura   ");
  delay(5000);
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you’ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  struct Lecturas datos;
  receive(&datos);
  temperatura = datos.temp;
  humedad = datos.hum;
  unsigned long gas = getUnsignedLong(datos.gas,0);
  CalcularCalidadAire(gas);
  lcd.setCursor (0, 0);
  lcd.print("TEMP:");
  lcd.print(datos.temp);
  lcd.print(" HUM:");
  lcd.print(datos.hum); lcd.print("% ");
  lcd.setCursor (0, 1);
  lcd.print("NIVEL GAS:");
  lcd.print(gas);lcd.print("    ");
}

bool receive(Lecturas* table)
{
  return (Serial.readBytes((char*)table, sizeof(Lecturas)) == sizeof(Lecturas));
}

void CalcularCalidadAire(int gasLevel)
{
  if(gasLevel == 0)
  {
    calidadAire = "No se recibió info";
    calidadAireBool = false;
    return;
  }
  if (gasLevel < 181)
  {
    calidadAire = "Buena...";
    calidadAireBool = true;
  }
  else if (gasLevel > 181 && gasLevel < 225)
  {
    calidadAire = "Regular...";
    calidadAireBool = true;
  }
  else if (gasLevel > 225 && gasLevel < 300)
  {
    calidadAire = "Mala...";
    calidadAireBool = false;
  }
  else if (gasLevel > 300 && gasLevel < 350)
  {
    calidadAire = "Radioactivo!";
    calidadAireBool = false;
  }
}

unsigned long getUnsignedLong(byte packet[], byte i) {
  unsigned long value = 0;
  value = (value * 256) + packet[i];
  value = (value * 256) + packet[i+1];
  value = (value * 256) + packet[i+2];
  value = (value * 256) + packet[i+3];
  return value;
}




